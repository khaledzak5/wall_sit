{"version":3,"file":"poseDetection-BJEmLmEJ.js","sources":["../../src/utils/poseDetection.js"],"sourcesContent":["// Pose detection utilities using MediaPipe\nclass PoseDetectionUtils {\n  constructor() {\n    this.pose = null;\n    this.isInitialized = false;\n  // Per-exercise state to avoid cross-contamination between different exercises\n  // Structure: { <mode>: { state: 'up'|'down'|'neutral'|..., count: number, extra... } }\n  this.perModeState = {};\n  const initMode = (mode) => ({ state: 'up', count: 0 });\n  this.perModeState['pushups'] = initMode('pushups');\n  this.perModeState['squats'] = initMode('squats');\n  this.perModeState['lunges'] = initMode('lunges');\n  this.perModeState['burpees'] = initMode('burpees');\n  this.perModeState['mountainclimbers'] = { state: 'neutral', count: 0, _lastLeftKneeY: null, _lastRightKneeY: null, _climberState: 'neutral', _lastClimberTime: 0 };\n  this.perModeState['highknees'] = { state: 'down', count: 0 };\n  this.perModeState['jumpingjacks'] = { state: 'down', count: 0 };\n  this.perModeState['sideplank'] = { state: 'neutral', count: 0, _stableCount: 0, _lastHipY: null, _lastShoulderY: null, _lastAnkleY: null, _lastTimestamp: 0 };\n  this.perModeState['plank'] = { state: 'neutral', count: 0, _stableCount: 0, _lastHipY: null, _lastShoulderY: null, _lastAnkleY: null, _lastTimestamp: 0 };\n    this.postureStatus = 'unknown'; // correct, incorrect, unknown\n    this.lastWarningTime = 0;\n    this.videoDimensionsLogged = false;\n    // Exercise mode and timing\n    this.exerciseMode = 'pushups'; // 'pushups' | 'plank' | 'squats' | 'lunges'\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n    this.onPushupCount = null;\n    this.onPostureChange = null;\n    this.onFormFeedback = null;\n    this.onTimeUpdate = null; // for plank seconds updates\n  }\n\n  setExerciseMode(mode) {\n    // ensure perModeState exists for the selected mode\n    if (!this.perModeState[this.exerciseMode]) {\n      this.perModeState[this.exerciseMode] = { state: 'up', count: 0 };\n    }\n    const normalized = String(mode || '').toLowerCase();\n    if (normalized === 'plank') this.exerciseMode = 'plank';\n    else if (normalized === 'squats' || normalized === 'squat') this.exerciseMode = 'squats';\n    else if (normalized === 'lunges' || normalized === 'lunge') this.exerciseMode = 'lunges';\n    else if (normalized === 'burpees' || normalized === 'burpee') this.exerciseMode = 'burpees';\n    else if (normalized.includes('mountain') || normalized.includes('climber')) this.exerciseMode = 'mountainclimbers';\n    else if (normalized.includes('high') && normalized.includes('knees')) this.exerciseMode = 'highknees';\n    else if (normalized.includes('jumping') && normalized.includes('jack')) this.exerciseMode = 'jumpingjacks';\n    else if (normalized.includes('side') && normalized.includes('plank')) this.exerciseMode = 'sideplank';\n    else this.exerciseMode = 'pushups';\n  }\n\n  // Initialize MediaPipe Pose\n  async initialize() {\n    try {\n      console.log('üöÄ Initializing MediaPipe Pose...');\n      \n      // Wait for MediaPipe to load if not ready\n      if (!window.Pose) {\n        console.warn('MediaPipe Pose not loaded yet, waiting...');\n        // Wait up to 10 seconds for MediaPipe to load\n        let attempts = 0;\n        while (!window.Pose && attempts < 50) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n          attempts++;\n          if (attempts % 10 === 0) {\n            console.log(`Still waiting for MediaPipe... (${attempts * 200}ms)`);\n          }\n        }\n        \n        if (!window.Pose) {\n          console.error('MediaPipe Pose failed to load after waiting');\n          return false;\n        }\n      }\n      \n      console.log('‚úÖ MediaPipe Pose found in window object');\n\n      this.pose = new window.Pose({\n        locateFile: (file) => {\n          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n        }\n      });\n\n      const config = window.MediaPipeConfig?.POSE_CONFIG || {\n        modelComplexity: 0,\n        smoothLandmarks: true,\n        enableSegmentation: false,\n        smoothSegmentation: false,\n        minDetectionConfidence: 0.5,\n        minTrackingConfidence: 0.5\n      };\n\n      this.pose.setOptions(config);\n      this.pose.onResults(this.onResults.bind(this));\n      \n      this.isInitialized = true;\n      console.log('MediaPipe Pose initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('Failed to initialize MediaPipe Pose:', error);\n      return false;\n    }\n  }\n\n  // Process video frame\n  async processFrame(videoElement) {\n    if (!this.isInitialized || !this.pose) {\n      console.log('‚ùå Pose not initialized or missing');\n      return null;\n    }\n\n    try {\n      // Only log occasionally to avoid spam\n      if (Math.random() < 0.05) {\n        console.log('üìπ Processing frame...');\n      }\n      \n      // Check if video dimensions are reasonable\n      if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {\n        if (Math.random() < 0.1) {\n          console.log('‚è≥ Video dimensions not ready yet');\n        }\n        return;\n      }\n      \n      // Log video dimensions only once per session\n      if (!this.videoDimensionsLogged) {\n        console.log(`üìè Video dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);\n        this.videoDimensionsLogged = true;\n      }\n      \n      // Allow larger videos but with a reasonable limit\n      const maxWidth = 1920;\n      const maxHeight = 1080;\n      if (videoElement.videoWidth > maxWidth || videoElement.videoHeight > maxHeight) {\n        console.log('‚ö†Ô∏è Video too large (>1920x1080), skipping frame');\n        return;\n      }\n      \n      await this.pose.send({ image: videoElement });\n    } catch (error) {\n      if (error.message?.includes('memory access out of bounds')) {\n        console.warn('üîÑ Memory error, skipping frame');\n        return;\n      }\n      console.error('Error processing frame:', error);\n    }\n  }\n\n  // Handle pose detection results\n  onResults(results) {\n    console.log('üéØ onResults called!', results.poseLandmarks ? `Found ${results.poseLandmarks.length} landmarks` : 'No landmarks');\n    \n    // Store results for drawing\n    this.lastResults = results;\n    \n    if (!results.poseLandmarks) {\n      this.postureStatus = 'unknown';\n      if (this.onPostureChange) {\n        this.onPostureChange('unknown', null);\n      }\n      // Stop plank timer if running\n      if (this.timerRunning) {\n        this.accumulatedCorrectMs += Date.now() - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n      return;\n    }\n\n    const landmarks = results.poseLandmarks;\n    \n    // Evaluate posture for the current exercise using the unified checker.\n    // Use a short consecutive-frame smoothing window to avoid brief spikes flipping posture state\n    const isPostureCorrectInstant = this.checkBackAlignment(landmarks);\n\n    // Initialize counters if missing\n    if (this._postureGoodCount == null) this._postureGoodCount = 0;\n    if (this._postureBadCount == null) this._postureBadCount = 0;\n\n    if (isPostureCorrectInstant) {\n      this._postureGoodCount += 1;\n      this._postureBadCount = 0;\n    } else {\n      this._postureBadCount += 1;\n      this._postureGoodCount = 0;\n    }\n\n  const POSTURE_GOOD_FRAMES = window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_GOOD_FRAMES ?? 3;\n  // For squats we require more consecutive bad frames before flipping to 'incorrect' to avoid\n  // false positives during normal descent. Default to 6 for squats, 4 otherwise.\n  const POSTURE_BAD_FRAMES = (this.exerciseMode === 'squats') ? (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 6) : (window.MediaPipeConfig?.SQUAT_CONFIG?.POSTURE_BAD_FRAMES ?? 4);\n\n    let smoothedStatus = this.postureStatus;\n    if (this._postureGoodCount >= POSTURE_GOOD_FRAMES) {\n      smoothedStatus = 'correct';\n    } else if (this._postureBadCount >= POSTURE_BAD_FRAMES) {\n      smoothedStatus = 'incorrect';\n    }\n\n    // For squats we don't want to show poor/incorrect posture feedback ‚Äî treat as correct.\n    if (this.exerciseMode === 'squats') {\n      smoothedStatus = 'correct';\n    }\n\n    if (smoothedStatus !== this.postureStatus) {\n      this.postureStatus = smoothedStatus;\n      if (this.onPostureChange) this.onPostureChange(this.postureStatus, landmarks);\n    }\n\n    // If posture is incorrect for strength/technique exercises, warn and normally skip counting.\n    // However, allow deep squat descents (hip below knee) to proceed to the squat counter so\n    // counting can occur if legs are stable. The squat counter itself still enforces stability\n    // and collapse checks.\n    const cardioExercises = ['mountainclimbers', 'highknees'];\n\n    // Compute hip/knee centers to detect a deep squat descent (hip below knee)\n    const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n    const leftHip = landmarks[cfg.LEFT_HIP || 23];\n    const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n    const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n    const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n    const hipCenter = leftHip && rightHip ? { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 } : null;\n    const kneeCenter = leftKnee && rightKnee ? { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 } : null;\n    const hipBelowKnee = hipCenter && kneeCenter ? (hipCenter.y > kneeCenter.y) : false;\n\n  // Do not emit posture warnings or block counting for squats; allow squat-specific logic to handle counting.\n  if (this.postureStatus !== 'correct' && !cardioExercises.includes(this.exerciseMode) && this.exerciseMode !== 'squats') {\n      const currentTime = Date.now();\n      const cooldown = window.MediaPipeConfig?.PLANK_CONFIG?.WARNING_COOLDOWN || 2000;\n\n      if (currentTime - this.lastWarningTime > cooldown) {\n        this.playWarningSound();\n        this.lastWarningTime = currentTime;\n\n        if (this.onFormFeedback) {\n          this.onFormFeedback({\n            message: \"Dangerous posture - straighten your back!\",\n            type: \"warning\",\n            timestamp: currentTime\n          });\n        }\n      }\n\n      // Stop plank timer while incorrect\n      if ((this.exerciseMode === 'plank' || this.exerciseMode === 'sideplank') && this.timerRunning) {\n        this.accumulatedCorrectMs += currentTime - this.startCorrectTimestampMs;\n        this.timerRunning = false;\n        this.startCorrectTimestampMs = 0;\n        if (this.onTimeUpdate) {\n          this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n        }\n      }\n\n      // Do not proceed to rep counting when posture is incorrect for non-cardio exercises\n      return;\n    }\n\n    // Posture is correct\n    if (this.exerciseMode === 'plank' || this.exerciseMode === 'sideplank') {\n      // For plank we require a stricter horizontal+stability check before counting time.\n      const now = Date.now();\n      const plankOk = this.isPlankStrictAndStable(landmarks, now);\n\n      if (plankOk) {\n        if (!this.timerRunning) {\n          this.startCorrectTimestampMs = now;\n          this.timerRunning = true;\n        }\n        const totalMs = this.accumulatedCorrectMs + (now - (this.startCorrectTimestampMs || now));\n        const seconds = Math.floor(totalMs / 1000);\n        if (this.onTimeUpdate) this.onTimeUpdate(seconds);\n      } else {\n        // Stop timer if it was running\n        if (this.timerRunning) {\n          this.accumulatedCorrectMs += now - this.startCorrectTimestampMs;\n          this.timerRunning = false;\n          this.startCorrectTimestampMs = 0;\n          if (this.onTimeUpdate) {\n            this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n          }\n        }\n      }\n\n      return;\n    }\n\n    // Count reps depending on mode\n      if (this.exerciseMode === 'squats') {\n        this.updateSquatCounter(landmarks);\n      } else if (this.exerciseMode === 'lunges') {\n        this.updateLungesCounter(landmarks);\n      } else if (this.exerciseMode === 'burpees') {\n        this.updateBurpeesCounter(landmarks);\n      } else if (this.exerciseMode === 'mountainclimbers') {\n        this.updateMountainClimbersCounter(landmarks);\n      } else if (this.exerciseMode === 'highknees') {\n        this.updateHighKneesCounter(landmarks);\n      } else if (this.exerciseMode === 'jumpingjacks') {\n        this.updateJumpingJacksCounter(landmarks);\n      } else if (this.exerciseMode === 'sideplank') {\n        this.updateSidePlankCounter(landmarks);\n      } else {\n        this.updatePushupCounter(landmarks);\n      }\n  }\n\n  // Calculate angle between three points\n  calculateAngle(point1, point2, point3) {\n    const radians = Math.atan2(point3.y - point2.y, point3.x - point2.x) - \n                   Math.atan2(point1.y - point2.y, point1.x - point2.x);\n    let angle = Math.abs(radians * 180.0 / Math.PI);\n    \n    if (angle > 180.0) {\n      angle = 360 - angle;\n    }\n    \n    return angle;\n  }\n\n  // Strict plank check: require near-horizontal torso and low movement across consecutive frames\n  isPlankStrictAndStable(landmarks, nowMs) {\n    try {\n      const cfg = window.MediaPipeConfig?.PLANK_CONFIG || {};\n      const LEFT_SHOULDER = cfg.LEFT_SHOULDER || 11;\n      const RIGHT_SHOULDER = cfg.RIGHT_SHOULDER || 12;\n      const LEFT_HIP = cfg.LEFT_HIP || 23;\n      const RIGHT_HIP = cfg.RIGHT_HIP || 24;\n      const LEFT_ANKLE = cfg.LEFT_ANKLE || 27;\n      const RIGHT_ANKLE = cfg.RIGHT_ANKLE || 28;\n\n      const leftShoulder = landmarks[LEFT_SHOULDER];\n      const rightShoulder = landmarks[RIGHT_SHOULDER];\n      const leftHip = landmarks[LEFT_HIP];\n      const rightHip = landmarks[RIGHT_HIP];\n      const leftAnkle = landmarks[LEFT_ANKLE];\n      const rightAnkle = landmarks[RIGHT_ANKLE];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      // Require at least shoulders and hips on one side or both for reliable horizontal check\n      const leftSideOk = vis(leftShoulder) && vis(leftHip);\n      const rightSideOk = vis(rightShoulder) && vis(rightHip);\n      if (!leftSideOk && !rightSideOk) return false;\n\n      // Compute torso horizontal orientation (prefer side-view angle when available)\n      let horizontalOk = false;\n  const MIN_SIDE_ANGLE = cfg.MIN_SIDE_ANGLE ?? 155; // degrees\n      if (vis(leftShoulder) && vis(leftHip) && vis(leftAnkle)) {\n        const sideAngle = this.calculateAngle(leftShoulder, leftHip, leftAnkle);\n        horizontalOk = sideAngle >= MIN_SIDE_ANGLE;\n      } else if (vis(rightShoulder) && vis(rightHip) && vis(rightAnkle)) {\n        const sideAngle = this.calculateAngle(rightShoulder, rightHip, rightAnkle);\n        horizontalOk = sideAngle >= MIN_SIDE_ANGLE;\n      } else {\n        // front-facing fallback: shoulder-hip axis near horizontal\n  const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n  const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n  const dx = shoulderCenter.x - hipCenter.x;\n  const dy = shoulderCenter.y - hipCenter.y;\n  const orientDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n  // Allow slightly more tolerance for imperfect camera angles / small movements\n  const HORIZ_MAX = cfg.HORIZ_MAX_DEG ?? 30;\n  horizontalOk = (orientDeg <= HORIZ_MAX) || (orientDeg >= (180 - HORIZ_MAX));\n      }\n\n      if (!horizontalOk) return false;\n\n      // Stability: ensure minimal movement in key points across consecutive frames\n  // Use per-mode state so sideplank and plank maintain independent stability counters\n  const state = this.perModeState[this.exerciseMode] || this.perModeState['plank'];\n      const hipY = (leftHip.y + rightHip.y) / 2;\n      const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n      const ankleY = (leftAnkle && rightAnkle) ? ((leftAnkle.y + rightAnkle.y) / 2) : null;\n\n  // Allow more movement per second (user may sway slightly) ‚Äî increase default tolerance\n  const maxDeltaPerSec = cfg.MAX_DELTA_PER_SEC ?? 0.25; // normalized units per second\n      const now = nowMs || Date.now();\n      const dt = Math.max(1, now - (state._lastTimestamp || now));\n\n      let hipDelta = state._lastHipY == null ? 0 : Math.abs(hipY - state._lastHipY);\n      let shoulderDelta = state._lastShoulderY == null ? 0 : Math.abs(shoulderY - state._lastShoulderY);\n      let ankleDelta = (ankleY == null || state._lastAnkleY == null) ? 0 : Math.abs(ankleY - state._lastAnkleY);\n\n      // Normalize deltas to per-second rates\n      const hipRate = hipDelta * (1000 / dt);\n      const shoulderRate = shoulderDelta * (1000 / dt);\n      const ankleRate = ankleDelta * (1000 / dt);\n\n      const motionTooHigh = (hipRate > maxDeltaPerSec) || (shoulderRate > maxDeltaPerSec) || (ankleY != null && ankleRate > maxDeltaPerSec);\n\n      if (!motionTooHigh) {\n        state._stableCount = (state._stableCount || 0) + 1;\n      } else {\n        state._stableCount = 0;\n      }\n\n      // Update last positions and timestamp for next frame\n      state._lastHipY = hipY;\n      state._lastShoulderY = shoulderY;\n      if (ankleY != null) state._lastAnkleY = ankleY;\n      state._lastTimestamp = now;\n\n  // Require fewer consecutive 'stable' frames so small adjustments don't block counting\n  const REQUIRED_STABLE_FRAMES = cfg.REQUIRED_STABLE_FRAMES ?? 4;\n      const stableEnough = state._stableCount >= REQUIRED_STABLE_FRAMES;\n\n      // Additionally enforce that user is not upright (filter out standing or knee-supported poses)\n      // Use hip vs ankle vertical gap when ankles visible\n      if (ankleY != null) {\n        const hipAnkleDy = Math.abs(hipY - ankleY);\n        // Reduce required hip-ankle gap so cameras that crop feet or users on soft surfaces still count\n        const MIN_HIP_ANKLE_DY = cfg.MIN_HIP_ANKLE_DY ?? 0.06;\n        if (hipAnkleDy < MIN_HIP_ANKLE_DY) return false;\n      }\n\n      return stableEnough;\n    } catch (e) {\n      console.error('isPlankStrictAndStable error', e);\n      return false;\n    }\n  }\n\n  // Detect stable push-up start pose: torso roughly horizontal and ankles visible (proxy for being on toes)\n  isPushupStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftAnkle) || !vis(rightAnkle)) {\n        return false;\n      }\n\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n\n      // torso vertical difference small -> near horizontal\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const THRESH = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_TORSO_DY ?? 0.08;\n      if (torsoDy > THRESH) return false;\n\n      // ankles visible and reasonably below hips (on toes) as an extra proxy\n      const ankleBelowHip = ((leftAnkle.y + rightAnkle.y) / 2) > hipCenterY;\n      if (!ankleBelowHip) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Detect stable squat start pose: standing upright with hips above knees and torso approximately vertical\n  isSquatStartPose(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      // Require shoulders, hips and knees for a reliable standing start pose.\n      // Ankles are optional because many webcams/cameras crop the feet.\n      if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n        return false;\n      }\n\n      const hipY = (leftHip.y + rightHip.y) / 2;\n      const kneeY = (leftKnee.y + rightKnee.y) / 2;\n      // In normalized coordinates hip above knee when standing\n      const gap = kneeY - hipY; // positive when hip above knee\n  const GAP_MIN = window.MediaPipeConfig?.SQUAT_CONFIG?.START_HIP_KNEE_GAP ?? 0.01;\n      if (gap < GAP_MIN) return false;\n\n      // Torso should be roughly vertical when standing\n      const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n      const hipCenter = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const dx = shoulderCenter.x - hipCenter.x;\n      const dy = shoulderCenter.y - hipCenter.y;\n      const angDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI); // similar to torso tilt in squat logic\n  const MIN_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MIN_DEG ?? 60;\n  const MAX_VERT = window.MediaPipeConfig?.SQUAT_CONFIG?.STANDING_TORSO_MAX_DEG ?? 120;\n      if (angDeg < MIN_VERT || angDeg > MAX_VERT) return false;\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Check back alignment for posture\n  checkBackAlignment(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      // Require visibility. For plank allow side-view (one side) visibility; for other exercises require both sides for stability.\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      if (this.exerciseMode === 'plank') {\n        const leftSideOk = vis(leftShoulder) && vis(leftHip);\n        const rightSideOk = vis(rightShoulder) && vis(rightHip);\n        if (!leftSideOk && !rightSideOk) {\n          // Not enough landmarks to evaluate plank reliably\n          return false;\n        }\n      } else if (this.exerciseMode === 'pushups') {\n        // For push-ups we only require both shoulders and hips to be visible.\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip)) {\n          return false;\n        }\n      } else {\n        // For other exercises require knees visible for stability\n        if (!vis(leftShoulder) || !vis(rightShoulder) || !vis(leftHip) || !vis(rightHip) || !vis(leftKnee) || !vis(rightKnee)) {\n          return false;\n        }\n      }\n\n      // Calculate center points\n      const shoulderCenter = {\n        x: (leftShoulder.x + rightShoulder.x) / 2,\n        y: (leftShoulder.y + rightShoulder.y) / 2\n      };\n      \n      const hipCenter = {\n        x: (leftHip.x + rightHip.x) / 2,\n        y: (leftHip.y + rightHip.y) / 2\n      };\n      \n      const kneeCenter = {\n        x: (leftKnee.x + rightKnee.x) / 2,\n        y: (leftKnee.y + rightKnee.y) / 2\n      };\n      const ankleCenter = (vis(leftAnkle) && vis(rightAnkle)) ? {\n        x: (leftAnkle.x + rightAnkle.x) / 2,\n        y: (leftAnkle.y + rightAnkle.y) / 2\n      } : null;\n\n      // Vectors for straightness\n      const targetPoint = ankleCenter || kneeCenter;\n      const v1 = { x: shoulderCenter.x - hipCenter.x, y: shoulderCenter.y - hipCenter.y };\n      const v2 = targetPoint ? { x: targetPoint.x - hipCenter.x, y: targetPoint.y - hipCenter.y } : null;\n\n      let isGoodPosture = false;\n      if (this.exerciseMode === 'plank') {\n        // Plank: support both front-facing and side-view evaluation.\n        const cfg = window.MediaPipeConfig?.PLANK_CONFIG || {};\n\n        // Prefer side-view detection when one full side is visible (shoulder, hip, ankle)\n        const leftSideVisible = vis(leftShoulder) && vis(leftHip) && vis(leftAnkle);\n        const rightSideVisible = vis(rightShoulder) && vis(rightHip) && vis(rightAnkle);\n\n        if (leftSideVisible || rightSideVisible) {\n          const shoulder = leftSideVisible ? leftShoulder : rightShoulder;\n          const hip = leftSideVisible ? leftHip : rightHip;\n          const ankle = leftSideVisible ? leftAnkle : rightAnkle;\n\n          // Angle at hip between shoulder-hip-ankle: near 180¬∞ for a straight plank\n          const sideAngle = this.calculateAngle(shoulder, hip, ankle);\n          const minSideAngle = cfg.MIN_SIDE_ANGLE ?? 155; // degrees\n\n          isGoodPosture = sideAngle >= minSideAngle;\n\n          // optional knee check when both ankles visible\n          if (isGoodPosture && ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            const kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n            isGoodPosture = isGoodPosture && kneeOk;\n          }\n\n        } else {\n          // Fallback: use center-based straightness + orientation as before (front-facing)\n          let cosSim = -1;\n          if (v2) {\n            const mag1 = Math.hypot(v1.x, v1.y) || 1;\n            const mag2 = Math.hypot(v2.x, v2.y) || 1;\n            cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          }\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          const straightEnough = v2 ? (absCos >= (cfg.STRAIGHT_ABS_COS_MIN ?? 0.90)) : false;\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const orientDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          const horizMax = cfg.HORIZ_MAX_DEG ?? 35;\n          const nearHorizontal = (orientDeg <= horizMax) || (orientDeg >= (180 - horizMax));\n          let kneeOk = true;\n          if (ankleCenter) {\n            const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n            const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n            const kneeMin = cfg.KNEE_MIN_DEG ?? 150;\n            kneeOk = (leftKneeAngle >= kneeMin) && (rightKneeAngle >= kneeMin);\n          }\n          isGoodPosture = straightEnough && nearHorizontal && kneeOk;\n        }\n\n      } else if (this.exerciseMode === 'squats') {\n        // Squats: accept normal descent (hip moving below knee) as a valid posture.\n        // Only flag 'BAD' when there's severe hip/back collapse (rounded back).\n        const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n        const hipAngleLeft = this.calculateAngle(leftShoulder, leftHip, leftKnee);\n        const hipAngleRight = this.calculateAngle(rightShoulder, rightHip, rightKnee);\n        const hipAngle = (hipAngleLeft + hipAngleRight) / 2;\n        // Configurable thresholds\n        const hipAngleMin = scfg.HIP_ANGLE_MIN ?? 120; // generous minimum for 'upright' expectation\n        const collapseThreshold = scfg.HIP_ANGLE_COLLAPSE ?? 60; // below this -> collapsed (bad)\n        const dx = shoulderCenter.x - hipCenter.x;\n        const dy = shoulderCenter.y - hipCenter.y;\n        const torsoTiltDeg = Math.abs(Math.atan2(dx, -dy) * 180 / Math.PI);\n        const tiltMax = scfg.TORSO_TILT_MAX ?? 60;\n\n        // Determine hip vs knee vertical relationship (allow descent)\n        const hipBelowKnee = kneeCenter && (hipCenter.y > kneeCenter.y);\n\n        const collapseTiltMin = scfg.COLLAPSE_TILT_MIN ?? 70; // require significant forward rounding\n        if (hipAngle < collapseThreshold && torsoTiltDeg > collapseTiltMin) {\n          // Severe collapse (rounded back + low hip angle) ‚Äî definitely bad\n          isGoodPosture = false;\n        } else if (hipBelowKnee) {\n          // Normal squat descent ‚Äî accept as good (as long as collapse not detected)\n          isGoodPosture = true;\n        } else {\n          // Standing/upright checks: require reasonable hip angle and torso tilt\n          isGoodPosture = (hipAngle >= hipAngleMin) && (torsoTiltDeg <= tiltMax);\n        }\n      } else {\n        // Push-ups: prefer a dedicated horizontal-body check.\n        // Two modes: side view (ankles visible) -> use straight-line similarity as before.\n        // Front/angled view (no ankle visibility) -> check shoulder-hip orientation close to horizontal\n        const cfg = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n        const SIDE_ABS_COS_MIN = cfg.SIDE_ABS_COS_MIN ?? 0.82; // slightly more lenient\n        const HORIZ_TORSO_MAX_DEG = cfg.HORIZ_TORSO_MAX_DEG ?? 35; // allow more tilt\n\n        // If ankle center available assume side/diagonal view and use cos similarity\n        if (ankleCenter && v2) {\n          let cosSim = -1;\n          const mag1 = Math.hypot(v1.x, v1.y) || 1;\n          const mag2 = Math.hypot(v2.x, v2.y) || 1;\n          cosSim = (v1.x * v2.x + v1.y * v2.y) / (mag1 * mag2);\n          const absCos = Math.abs(Math.max(-1, Math.min(1, cosSim)));\n          isGoodPosture = absCos >= SIDE_ABS_COS_MIN;\n        } else {\n          // Fallback: check that shoulder-hip axis is near horizontal (small dy)\n          const dx = shoulderCenter.x - hipCenter.x;\n          const dy = shoulderCenter.y - hipCenter.y;\n          const angDeg = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);\n          // angle near 0 or near 180 -> horizontal\n          const nearHorizontal = (angDeg <= HORIZ_TORSO_MAX_DEG) || (angDeg >= (180 - HORIZ_TORSO_MAX_DEG));\n          // Also ensure it's not standing (i.e., torso nearly vertical)\n          const nearVertical = (angDeg >= 90 - 20 && angDeg <= 90 + 20);\n          isGoodPosture = nearHorizontal && !nearVertical;\n        }\n      }\n\n      console.log(`üèÉ Posture(${this.exerciseMode}): ${isGoodPosture ? 'GOOD' : 'BAD'}`);\n      \n      return isGoodPosture;\n    } catch (error) {\n      console.error('Error checking back alignment:', error);\n      return false;\n    }\n  }\n\n  // Update push-up counter\n  updatePushupCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const pushupConfig = window.MediaPipeConfig?.PUSHUP_CONFIG || {};\n      \n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n\n      if (!leftShoulder || !leftElbow || !leftWrist || !rightShoulder || !rightElbow || !rightWrist || !leftHip || !rightHip) {\n        return;\n      }\n\n      // Calculate elbow angles\n      const leftElbowAngle = this.calculateAngle(leftShoulder, leftElbow, leftWrist);\n      const rightElbowAngle = this.calculateAngle(rightShoulder, rightElbow, rightWrist);\n      const avgElbowAngle = (leftElbowAngle + rightElbowAngle) / 2;\n\n      // Average shoulder position (for height detection)\n      const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n\n      const downThreshold = pushupConfig.ELBOW_ANGLE_DOWN || 95;\n      const upThreshold = pushupConfig.ELBOW_ANGLE_UP || 155;\n      const shoulderHeightThreshold = pushupConfig.SHOULDER_HEIGHT_DOWN || 0.02;\n\n      // Push-up position: elbows bent OR shoulders close to ground\n      // Determine if user is likely standing: if shoulders are well above hips and torso vertical\n      const shoulderHipDy = Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2));\n      const torsoVerticalThreshold = pushupConfig.TORSO_VERTICAL_DY ?? 0.15; // if shoulders far above hips (normalized units)\n      const isLikelyStanding = shoulderHipDy < (pushupConfig.STANDING_DY_MIN ?? 0.05) ? false : ((leftShoulder.y + rightShoulder.y) / 2) < ((leftHip.y + rightHip.y) / 2) - (pushupConfig.STANDING_DY_MIN ?? 0.02);\n\n      // Baseline shoulder level (approx when 'up' state) ‚Äî store per-mode baseline\n      const pstate = this.perModeState['pushups'];\n      if (!pstate._baselineShoulderY) {\n        // initialize baseline to current shoulder Y when pose roughly horizontal\n        pstate._baselineShoulderY = avgShoulderY;\n      }\n\n      // If posture is not horizontal, don't update baseline; else slowly adapt baseline\n      if (Math.abs(((leftShoulder.y + rightShoulder.y) / 2) - ((leftHip.y + rightHip.y) / 2)) < 0.12) {\n        // adapt baseline slowly\n        pstate._baselineShoulderY = (pstate._baselineShoulderY * 0.95) + (avgShoulderY * 0.05);\n      }\n\n      // Push-up position: significant drop from baseline OR elbow angle threshold\n      const shoulderDrop = avgShoulderY - (pstate._baselineShoulderY || avgShoulderY);\n      const shoulderDropThreshold = pushupConfig.SHOULDER_DROP_THRESHOLD ?? 0.06; // normalized units\n      const pushupPosition = (avgElbowAngle <= downThreshold) || (shoulderDrop >= shoulderDropThreshold) || (avgShoulderY >= (1 - shoulderHeightThreshold));\n      \n      // Standing position: elbows straight and shoulders high (not horizontal)\n      const standingPosition = (avgElbowAngle >= upThreshold) && isLikelyStanding;\n\n      // In-position gating: require user to assume a stable push-up start pose before starting counting\n      if (!pstate._inPositionCount) pstate._inPositionCount = 0;\n      const inStart = this.isPushupStartPose(landmarks);\n      if (inStart) {\n        pstate._inPositionCount += 1;\n      } else {\n        pstate._inPositionCount = 0;\n      }\n\n      const REQUIRED_STABLE_FRAMES = window.MediaPipeConfig?.PUSHUP_CONFIG?.START_STABLE_FRAMES ?? 6; // ~6 frames\n      pstate._isInStartPose = pstate._inPositionCount >= REQUIRED_STABLE_FRAMES;\n\n      // Debounce reps: minimum ms between consecutive counts\n      const MIN_REP_MS = window.MediaPipeConfig?.PUSHUP_CONFIG?.MIN_REP_MS ?? 400;\n      if (!pstate._lastRepAt) pstate._lastRepAt = 0;\n      const now = Date.now();\n\n      // Only count if posture is correct and user is in start pose\n      if (this.postureStatus !== 'correct' || !pstate._isInStartPose) {\n        return; // do not count\n      }\n\n      if (pstate.state === 'up') {\n        if (pushupPosition && (now - pstate._lastRepAt) > MIN_REP_MS) {\n          pstate.state = 'down';\n          pstate.count += 1; // Count on descent\n          pstate._lastRepAt = now;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(pstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Push-up ${pstate.count}`, type: 'success', timestamp: now });\n          }\n        }\n      } else if (pstate.state === 'down') {\n        // return to up when standingPosition or full extension detected\n        if (standingPosition || (!pushupPosition && avgElbowAngle >= upThreshold)) {\n          pstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating push-up counter:', error);\n    }\n  }\n\n  // Update squat counter\n  updateSquatCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const scfg = window.MediaPipeConfig?.SQUAT_CONFIG || {};\n\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      const leftShoulder = landmarks[cfg.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[cfg.RIGHT_SHOULDER || 12];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle || !leftShoulder || !rightShoulder) return;\n\n      // Check if user is in horizontal position (like pushup) - show warning but DO NOT count if so\n      const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;\n      const hipCenterY = (leftHip.y + rightHip.y) / 2;\n      const head = landmarks[cfg.NOSE || 0];\n      const torsoDy = Math.abs(shoulderCenterY - hipCenterY);\n      const HORIZONTAL_THRESHOLD = 0.08; // Same threshold as pushup detection\n      // Check if head is at same y level as hips (head down, body horizontal)\n      const headHipDy = Math.abs((head?.y ?? 0) - hipCenterY);\n      const HEAD_HIP_HORIZONTAL_THRESHOLD = 0.10; // If head and hip are close in y, likely horizontal\n      let isHorizontalLikePushup = false;\n      if (torsoDy <= HORIZONTAL_THRESHOLD && headHipDy <= HEAD_HIP_HORIZONTAL_THRESHOLD) {\n        isHorizontalLikePushup = true;\n        // Optional: show warning\n        if (this.onFormFeedback) {\n          this.onFormFeedback({ \n            message: 'Ÿàÿ∂ÿπ ÿßŸÑÿ¨ÿ≥ŸÖ ÿ£ŸÅŸÇŸäÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠', \n            type: 'warning', \n            timestamp: Date.now() \n          });\n        }\n      }\n\n      // Check if hands are on the ground (like pushup)\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      // Consider hands on ground if both wrists are at or below the level of the ankles (with small margin)\n      const HANDS_ON_GROUND_THRESHOLD = 0.07; // allow small margin\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: 'ÿßŸÑŸäÿØŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ÿ±ÿ∂ÿå ŸÑŸÜ Ÿäÿ™ŸÖ ÿßŸÑÿπÿØ ÿ•ŸÑÿß ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿßÿ≥ŸÉŸàÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠',\n              type: 'warning',\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n\n      // Average sides for stability\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      const knee = { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 };\n      const ankle = { x: (leftAnkle.x + rightAnkle.x) / 2, y: (leftAnkle.y + rightAnkle.y) / 2 };\n      const shoulder = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };\n\n      // Knee angle using hip-knee-ankle\n      const kneeAngleLeft = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const kneeAngleRight = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      const avgKneeAngle = (kneeAngleLeft + kneeAngleRight) / 2;\n\n      // Check leg stability - both legs should be moving together (not one leg down)\n      const leftKneeY = leftKnee.y;\n      const rightKneeY = rightKnee.y;\n      const kneeHeightDiff = Math.abs(leftKneeY - rightKneeY);\n      const LEG_STABILITY_THRESHOLD = 0.05; // Maximum difference between left and right knee heights\n      \n      const legsStable = kneeHeightDiff <= LEG_STABILITY_THRESHOLD;\n      \n      // Check if knees are bending (squatting down)\n      const kneesBending = avgKneeAngle < 120; // Knees bent when angle is less than 120 degrees\n\n      // Count based on hip position (lower back points)\n      const hipY = hip.y; // Y position of hips (lower = deeper)\n      const kneeY = knee.y; // Y position of knees\n      \n      // Hip goes below knee level = deep squat\n      const hipBelowKnee = hipY > kneeY;\n      // Hip goes back up above knee level = standing\n      const hipAboveKnee = hipY < kneeY;\n      \n      // State machine: count when hip goes down below knee level (use per-mode state)\n      const stateObj = this.perModeState['squats'];\n\n      // Debug logging\n      console.log('üîç Squat Debug:', {\n        legsStable,\n        kneesBending,\n        avgKneeAngle,\n        kneeHeightDiff,\n        hipBelowKnee,\n        hipAboveKnee,\n        state: stateObj.state,\n        count: stateObj.count\n      });\n\n      // Simplified squat counting: count when hips go below knees with stable legs\n      const MIN_REP_MS = window.MediaPipeConfig?.SQUAT_CONFIG?.MIN_REP_MS ?? 500;\n      if (!stateObj._lastRepAt) stateObj._lastRepAt = 0;\n      const now = Date.now();\n\n      if (stateObj.state === 'up') {\n        // Count if hips go below knees and legs are stable, and NOT in horizontal position or hands on ground\n        if (hipBelowKnee && legsStable && !isHorizontalLikePushup && !handsOnGround && (now - stateObj._lastRepAt) > MIN_REP_MS) {\n          stateObj.state = 'down';\n          stateObj.count += 1;\n          stateObj._lastRepAt = now;\n          console.log('üéØ Squat counted! Count:', stateObj.count);\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(stateObj.count);\n        } else {\n          // Debug why counting didn't happen\n          if (!hipBelowKnee) {\n            console.log('‚ùå Not counting: Hips not below knees');\n          } else if (!legsStable) {\n            console.log('‚ùå Not counting: Legs not stable (one leg down)');\n          } else if (isHorizontalLikePushup) {\n            console.log('‚ùå Not counting: Body is horizontal like pushup');\n          } else if (handsOnGround) {\n            console.log('‚ùå Not counting: Hands are on the ground');\n          } else if ((now - stateObj._lastRepAt) <= MIN_REP_MS) {\n            console.log('‚ùå Not counting: Too soon since last rep');\n          }\n        }\n      } else if (stateObj.state === 'down') {\n        if (hipAboveKnee) {\n          stateObj.state = 'up';\n          console.log('‚¨ÜÔ∏è Squat state changed to UP');\n        }\n      }\n    } catch (error) {\n      console.error('Error updating squat counter:', error);\n    }\n  }\n\n  // Update lunges counter\n  updateLungesCounter(landmarks) {\n    try {\n      const cfg = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const lcfg = window.MediaPipeConfig?.LUNGES_CONFIG || {};\n      const leftHip = landmarks[cfg.LEFT_HIP || 23];\n      const rightHip = landmarks[cfg.RIGHT_HIP || 24];\n      const leftKnee = landmarks[cfg.LEFT_KNEE || 25];\n      const rightKnee = landmarks[cfg.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[cfg.RIGHT_ANKLE || 28];\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n      \n      // Check if hands are on the ground (like pushup) - don't count lunges if hands on ground\n      const leftWrist = landmarks[cfg.LEFT_WRIST || 15];\n      const rightWrist = landmarks[cfg.RIGHT_WRIST || 16];\n      const leftFoot = landmarks[cfg.LEFT_ANKLE || 27];\n      const rightFoot = landmarks[cfg.RIGHT_ANKLE || 28];\n      const HANDS_ON_GROUND_THRESHOLD = 0.07;\n      let handsOnGround = false;\n      if (leftWrist && rightWrist && leftFoot && rightFoot) {\n        const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n        const avgFootY = (leftFoot.y + rightFoot.y) / 2;\n        if (avgWristY >= avgFootY - HANDS_ON_GROUND_THRESHOLD) {\n          handsOnGround = true;\n        }\n      }\n      \n      // Average hip position\n      const hip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };\n      // Calculate knee angles\n      const leftKneeAngle = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const rightKneeAngle = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n      // Determine which leg is front (more bent knee) - allow both legs to be counted\n      const leftKneeBent = leftKneeAngle < rightKneeAngle;\n      const frontKnee = leftKneeBent ? leftKnee : rightKnee;\n      const backKnee = leftKneeBent ? rightKnee : leftKnee;\n      const frontKneeAngle = leftKneeBent ? leftKneeAngle : rightKneeAngle;\n      const backKneeAngle = leftKneeBent ? rightKneeAngle : leftKneeAngle;\n      \n      // Also check the opposite leg position (for alternating lunges)\n      const rightKneeBent = rightKneeAngle < leftKneeAngle;\n      const altFrontKnee = rightKneeBent ? rightKnee : leftKnee;\n      const altBackKnee = rightKneeBent ? leftKnee : rightKnee;\n      const altFrontKneeAngle = rightKneeBent ? rightKneeAngle : leftKneeAngle;\n      const altBackKneeAngle = rightKneeBent ? leftKneeAngle : rightKneeAngle;\n      // Hip position relative to front knee\n      const hipBelowFrontKnee = hip.y > frontKnee.y;\n      // Lunge position based on the image: one leg forward, body leaning forward, back knee close to ground\n      const KNEE_Y_DIFF_THRESHOLD = 0.06; // ŸÅÿ±ŸÇ Ÿàÿßÿ∂ÿ≠ ÿ®ŸäŸÜ ÿßŸÑÿ±ŸÉÿ®ÿ™ŸäŸÜ (ÿ±ÿ¨ŸÑ ŸÑŸÑÿ£ŸÖÿßŸÖ) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const BACK_KNEE_ANGLE_THRESHOLD = 120; // back knee bent (close to ground) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const FRONT_KNEE_ANGLE_THRESHOLD = 100; // front knee bent (stable support) - ÿ™Ÿàÿ≥Ÿäÿπ\n      const HIP_FORWARD_THRESHOLD = 0.08; // hip leaning forward over front leg - ÿ™Ÿàÿ≥Ÿäÿπ\n      \n      const kneeYDiff = Math.abs(leftKnee.y - rightKnee.y);\n      const oneLegForward = kneeYDiff > KNEE_Y_DIFF_THRESHOLD;\n      \n      // Check first leg position (left leg forward)\n      const backKneeBent = backKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const frontKneeBent = frontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const frontHip = leftKneeBent ? leftHip : rightHip;\n      const frontAnkle = leftKneeBent ? leftAnkle : rightAnkle;\n      const hipForwardLean = Math.abs(frontHip.x - frontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition1 = oneLegForward && backKneeBent && frontKneeBent && hipForwardLean;\n      \n      // Check second leg position (right leg forward)\n      const altBackKneeBent = altBackKneeAngle < BACK_KNEE_ANGLE_THRESHOLD;\n      const altFrontKneeBent = altFrontKneeAngle < FRONT_KNEE_ANGLE_THRESHOLD;\n      const altFrontHip = rightKneeBent ? rightHip : leftHip;\n      const altFrontAnkle = rightKneeBent ? rightAnkle : leftAnkle;\n      const altHipForwardLean = Math.abs(altFrontHip.x - altFrontAnkle.x) < HIP_FORWARD_THRESHOLD;\n      const lungePosition2 = oneLegForward && altBackKneeBent && altFrontKneeBent && altHipForwardLean;\n      \n      // Either leg position counts as a lunge\n      const lungePosition = lungePosition1 || lungePosition2;\n      // Standing position: both knees straight\n      const standingPosition = (frontKneeAngle >= 160) && (backKneeAngle >= 150);\n      // Simple counting: count immediately when going down (like squats)\n      const lstate = this.perModeState['lunges'];\n      if (lstate.state === 'up') {\n        if (!handsOnGround && lungePosition) {\n          lstate.state = 'down';\n          lstate.count += 1; // Count immediately on descent\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(lstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({ message: `Lunge ${lstate.count}`, type: 'success', timestamp: Date.now() });\n          }\n        }\n      } else if (lstate.state === 'down') {\n        if (standingPosition) {\n          lstate.state = 'up'; // Reset state for next rep\n        }\n      }\n    } catch (error) {\n      console.error('Error updating lunges counter:', error);\n    }\n  }\n\n  // Add Burpees counter\n  // Update mountain climbers counter\n  updateMountainClimbersCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      \n      // Get key body points\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n\n      // Calculate vertical distances between knees and hips\n      const leftKneeToHipY = Math.abs(leftKnee.y - leftHip.y);\n      const rightKneeToHipY = Math.abs(rightKnee.y - rightHip.y);\n\n      // Initialize states if needed\n      if (!this._lastLeftKneeY) this._lastLeftKneeY = leftKnee.y;\n      if (!this._lastRightKneeY) this._lastRightKneeY = rightKnee.y;\n      if (!this._climberState) this._climberState = 'neutral';\n      if (!this._lastClimberTime) this._lastClimberTime = Date.now();\n      \n      const KNEE_THRESHOLD = 0.05; // How far the knee needs to move\n      const MIN_REP_TIME = 250; // Minimum time between reps (ms)\n      const currentTime = Date.now();\n\n      // Calculate knee movements\n      const leftKneeMove = leftKnee.y - this._lastLeftKneeY;\n      const rightKneeMove = rightKnee.y - this._lastRightKneeY;\n\n      // Check for significant knee movements in opposite directions\n      const isAlternating = (leftKneeMove > KNEE_THRESHOLD && rightKneeMove < -KNEE_THRESHOLD) ||\n                           (leftKneeMove < -KNEE_THRESHOLD && rightKneeMove > KNEE_THRESHOLD);\n\n      // State machine for counting alternating leg movements\n      const cmode = this.perModeState['mountainclimbers'];\n      if (cmode._climberState === 'neutral') {\n        if (isAlternating && (currentTime - cmode._lastClimberTime > MIN_REP_TIME)) {\n          cmode._climberState = 'moving';\n          cmode._lastClimberTime = currentTime;\n          // Count the rep\n          cmode.count += 1;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(cmode.count);\n          if (this.onFormFeedback) {\n            const leg = leftKneeMove > rightKneeMove ? 'Left' : 'Right';\n            this.onFormFeedback({\n              message: `${leg} knee drive - Rep ${cmode.count}`,\n              type: 'success',\n              timestamp: currentTime\n            });\n          }\n        }\n      } else if (cmode._climberState === 'moving') {\n        if (!isAlternating) {\n          cmode._climberState = 'neutral';\n        }\n      }\n\n      // Update last positions\n      cmode._lastLeftKneeY = leftKnee.y;\n      cmode._lastRightKneeY = rightKnee.y;\n\n      // Form feedback for incorrect movement\n      if (Math.abs(leftHip.y - rightHip.y) > 0.1) { // Hips not level\n        if (this.onFormFeedback && Math.random() < 0.1) {\n          this.onFormFeedback({\n            message: \"Keep hips level!\",\n            type: \"warning\",\n            timestamp: currentTime\n          });\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating mountain climbers counter:', error);\n    }\n  }\n\n  updateBurpeesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      // ŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ£ÿ≥ ŸàÿßŸÑŸäÿØŸäŸÜ\n      const nose = landmarks[config.NOSE || 0];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftIndex = landmarks[config.LEFT_INDEX || 19];\n      const rightIndex = landmarks[config.RIGHT_INDEX || 20];\n      if (!nose || !leftWrist || !rightWrist) return;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑÿ±ÿ£ÿ≥\n      const headY = nose.y;\n      // ÿ£ÿπŸÑŸâ ŸÜŸÇÿ∑ÿ© ŸÑŸÑŸäÿØ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ\n      const leftHandY = leftIndex ? leftIndex.y : leftWrist.y;\n      const rightHandY = rightIndex ? rightIndex.y : rightWrist.y;\n      // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸäÿØŸäŸÜ ÿ£Ÿà ÿßŸÑÿ£ÿµÿßÿ®ÿπ ÿ£ÿπŸÑŸâ ŸÖŸÜ ÿßŸÑÿ±ÿ£ÿ≥ (ÿ£ŸÇŸÑ ŸÅŸä ŸÇŸäŸÖÿ© y)\n      const handsAboveHead = (leftHandY < headY && rightHandY < headY);\n      // ŸÖŸÜÿ∑ŸÇ ÿßŸÑÿπÿØ\n      if (!this._burpeeState) this._burpeeState = 'ready';\n      if (!this.perModeState['burpees']._burpeeState) this.perModeState['burpees']._burpeeState = 'ready';\n      const bstate = this.perModeState['burpees'];\n      if (bstate._burpeeState === 'ready') {\n        if (handsAboveHead) {\n          bstate._burpeeState = 'jumping';\n          bstate.count += 1;\n          this.playSuccessSound(); // Play success sound\n          if (this.onPushupCount) this.onPushupCount(bstate.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: `Burpee ${bstate.count} - Hands above head!`,\n              type: 'success',\n              timestamp: Date.now()\n            });\n          }\n        }\n      } else if (bstate._burpeeState === 'jumping') {\n        if (!handsAboveHead) {\n          bstate._burpeeState = 'ready';\n        }\n      }\n    } catch (error) {\n      console.error('Error updating burpees counter:', error);\n    }\n  }\n\n  updateHighKneesCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return;\n\n      // Check if knee is at waist level or above (easier threshold)\n      const KNEE_HIP_THRESHOLD = 0.03; // Knee should be at waist level or above (easier)\n      const isLeftKneeHigh = (leftHip.y - leftKnee.y) > KNEE_HIP_THRESHOLD;\n      const isRightKneeHigh = (rightHip.y - rightKnee.y) > KNEE_HIP_THRESHOLD;\n\n      // Check if user is doing high knees movement (either leg up)\n      const isDoingHighKnees = isLeftKneeHigh || isRightKneeHigh;\n\n      // State machine for timing high knees (per-mode)\n      const hk = this.perModeState['highknees'];\n      if (!hk._highKneesState) hk._highKneesState = 'stopped';\n      if (!hk._startTime) hk._startTime = 0;\n      if (!hk._lastUpdateTime) hk._lastUpdateTime = 0;\n\n      const now = Date.now();\n      const MIN_MOVEMENT_INTERVAL = 100; // Minimum time between movements (ms)\n\n      if (hk._highKneesState === 'stopped') {\n        // Start timing when user begins high knees movement\n        if (isDoingHighKnees) {\n          hk._highKneesState = 'active';\n          hk._startTime = now;\n          hk._lastUpdateTime = now;\n          hk.count = 0; // Reset count\n          console.log('üèÉ High Knees started!');\n        }\n      } else if (hk._highKneesState === 'active') {\n        if (isDoingHighKnees) {\n          // Continue timing while user is doing high knees\n          hk._lastUpdateTime = now;\n          const elapsedSeconds = Math.floor((now - hk._startTime) / 1000);\n          \n          // Update count (in seconds) every second\n          if (elapsedSeconds > hk.count) {\n            hk.count = elapsedSeconds;\n            if (this.onPushupCount) this.onPushupCount(hk.count);\n            console.log(`‚è±Ô∏è High Knees: ${elapsedSeconds} seconds`);\n          }\n        } else {\n          // Check if user stopped for too long\n          const timeSinceLastMovement = now - hk._lastUpdateTime;\n          if (timeSinceLastMovement > 1500) { // Stop if no movement for 1.5 seconds\n            hk._highKneesState = 'stopped';\n            console.log('‚èπÔ∏è High Knees stopped!');\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating high knees counter:', error);\n    }\n  }\n\n  // Update jumping jacks counter\n  updateJumpingJacksCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const jjConfig = window.MediaPipeConfig?.JUMPINGJACKS_CONFIG || {};\n\n      // Get key landmarks for jumping jacks\n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n\n      if (!leftShoulder || !rightShoulder || !leftHip || !rightHip || !leftKnee || !rightKnee || !leftElbow || !rightElbow || !leftWrist || !rightWrist || !leftAnkle || !rightAnkle) {\n        return;\n      }\n\n      // Calculate shoulder abduction angles (shoulder-elbow-wrist) - arms overhead\n      const leftShoulderAbduction = this.calculateAngle(leftElbow, leftShoulder, leftWrist);\n      const rightShoulderAbduction = this.calculateAngle(rightElbow, rightShoulder, rightWrist);\n\n      // Calculate hip abduction angles (hip-knee-ankle) - legs apart\n      const leftHipAbduction = this.calculateAngle(leftKnee, leftHip, leftAnkle);\n      const rightHipAbduction = this.calculateAngle(rightKnee, rightHip, rightAnkle);\n\n      // Calculate knee flexion angles (hip-knee-ankle)\n      const leftKneeFlexion = this.calculateAngle(leftHip, leftKnee, leftAnkle);\n      const rightKneeFlexion = this.calculateAngle(rightHip, rightKnee, rightAnkle);\n\n      // Simplified thresholds - make them more lenient for better detection\n      const SHOULDER_ABDUCTION_DOWN = jjConfig.SHOULDER_ABDUCTION_DOWN || 60;    // More lenient for arms down\n      const SHOULDER_ABDUCTION_UP = jjConfig.SHOULDER_ABDUCTION_UP || 120;      // More lenient for arms overhead\n      const HIP_ABDUCTION_DOWN = jjConfig.HIP_ABDUCTION_DOWN || 25;             // More lenient for legs together\n      const HIP_ABDUCTION_UP = jjConfig.HIP_ABDUCTION_UP || 30;                 // More lenient for legs apart\n\n      // Simplified state detection - focus on the main movements\n      const avgShoulderAbduction = (leftShoulderAbduction + rightShoulderAbduction) / 2;\n      const avgHipAbduction = (leftHipAbduction + rightHipAbduction) / 2;\n\n      // Alternative: Use position-based detection (more reliable)\n      const avgWristY = (leftWrist.y + rightWrist.y) / 2;\n      const avgShoulderY = (leftShoulder.y + rightShoulder.y) / 2;\n      const avgAnkleY = (leftAnkle.y + rightAnkle.y) / 2;\n      const avgHipY = (leftHip.y + rightHip.y) / 2;\n      \n      // Arms overhead: wrists above shoulders\n      const armsOverhead = avgWristY < avgShoulderY;\n      // Legs apart: ankles spread wider than hips\n      const legsApart = Math.abs(leftAnkle.x - rightAnkle.x) > Math.abs(leftHip.x - rightHip.x) * 1.2;\n\n      // UP state: arms overhead AND legs apart (using position OR angles)\n      const isUpState = (armsOverhead && legsApart) || (avgShoulderAbduction > SHOULDER_ABDUCTION_UP && avgHipAbduction > HIP_ABDUCTION_UP);\n\n      // DOWN state: arms down AND legs together (using position OR angles)\n      const isDownState = (!armsOverhead && !legsApart) || (avgShoulderAbduction < SHOULDER_ABDUCTION_DOWN && avgHipAbduction < HIP_ABDUCTION_DOWN);\n\n      // State machine for counting jumping jacks\n      const jjState = this.perModeState['jumpingjacks'];\n      \n      // Debounce reps: minimum ms between consecutive counts\n      const MIN_REP_MS = jjConfig.MIN_REP_MS || 800;\n      if (!jjState._lastRepAt) jjState._lastRepAt = 0;\n      const now = Date.now();\n\n      // Debug logging\n      console.log('üîç Jumping Jacks Debug:', {\n        // Angle-based detection\n        avgShoulderAbduction: Math.round(avgShoulderAbduction),\n        avgHipAbduction: Math.round(avgHipAbduction),\n        shoulderThresholdUp: SHOULDER_ABDUCTION_UP,\n        shoulderThresholdDown: SHOULDER_ABDUCTION_DOWN,\n        hipThresholdUp: HIP_ABDUCTION_UP,\n        hipThresholdDown: HIP_ABDUCTION_DOWN,\n        // Position-based detection\n        avgWristY: Math.round(avgWristY * 1000) / 1000,\n        avgShoulderY: Math.round(avgShoulderY * 1000) / 1000,\n        armsOverhead,\n        legsApart,\n        ankleDistance: Math.round(Math.abs(leftAnkle.x - rightAnkle.x) * 1000) / 1000,\n        hipDistance: Math.round(Math.abs(leftHip.x - rightHip.x) * 1000) / 1000,\n        // Final states\n        isUpState,\n        isDownState,\n        state: jjState.state,\n        count: jjState.count\n      });\n\n      // State machine: DOWN -> UP -> DOWN (count) -> repeat\n      if (jjState.state === 'down') {\n        // Transition to UP state when both arms and legs are in UP position (Peak Position)\n        // Add debouncing to prevent rapid state changes\n        if (isUpState && (now - (jjState._lastStateChange || 0)) > 300) {\n          jjState.state = 'up';\n          jjState._lastStateChange = now;\n          console.log('‚¨ÜÔ∏è Jumping Jack state changed to UP (Peak Position)');\n        }\n      } else if (jjState.state === 'up') {\n        // Complete the rep and count when transitioning back to DOWN state (Return to Starting Position)\n        // Ensure we've been in UP state for a minimum time and debounce the count\n        if (isDownState && (now - jjState._lastRepAt) > MIN_REP_MS && (now - (jjState._lastStateChange || 0)) > 300) {\n          jjState.state = 'down';\n          jjState.count += 1;\n          jjState._lastRepAt = now;\n          jjState._lastStateChange = now;\n          console.log('üéØ Jumping Jack counted! Count:', jjState.count);\n          this.playSuccessSound();\n          if (this.onPushupCount) this.onPushupCount(jjState.count);\n          if (this.onFormFeedback) {\n            this.onFormFeedback({\n              message: `Jumping Jack ${jjState.count}`,\n              type: 'success',\n              timestamp: now\n            });\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating jumping jacks counter:', error);\n    }\n  }\n\n  // Update side plank counter (time-based like regular plank)\n  updateSidePlankCounter(landmarks) {\n    try {\n      const config = window.MediaPipeConfig?.POSE_LANDMARKS || {};\n      const spConfig = window.MediaPipeConfig?.SIDEPLANK_CONFIG || {};\n\n      // Get key landmarks for side plank\n      const leftShoulder = landmarks[config.LEFT_SHOULDER || 11];\n      const rightShoulder = landmarks[config.RIGHT_SHOULDER || 12];\n      const leftElbow = landmarks[config.LEFT_ELBOW || 13];\n      const rightElbow = landmarks[config.RIGHT_ELBOW || 14];\n      const leftWrist = landmarks[config.LEFT_WRIST || 15];\n      const rightWrist = landmarks[config.RIGHT_WRIST || 16];\n      const leftHip = landmarks[config.LEFT_HIP || 23];\n      const rightHip = landmarks[config.RIGHT_HIP || 24];\n      const leftKnee = landmarks[config.LEFT_KNEE || 25];\n      const rightKnee = landmarks[config.RIGHT_KNEE || 26];\n      const leftAnkle = landmarks[config.LEFT_ANKLE || 27];\n      const rightAnkle = landmarks[config.RIGHT_ANKLE || 28];\n      const nose = landmarks[config.NOSE || 0];\n      const leftEar = landmarks[config.LEFT_EAR || 7];\n      const rightEar = landmarks[config.RIGHT_EAR || 8];\n\n      // Check visibility of key landmarks\n      const vis = (p) => p && (p.visibility == null || p.visibility > 0.5);\n      \n      // Determine which side is the support side (left or right)\n      // We'll check both sides and use the one with better visibility\n      const leftSideVisible = vis(leftShoulder) && vis(leftElbow) && vis(leftHip) && vis(leftKnee) && vis(leftAnkle);\n      const rightSideVisible = vis(rightShoulder) && vis(rightElbow) && vis(rightHip) && vis(rightKnee) && vis(rightAnkle);\n      \n      if (!leftSideVisible && !rightSideVisible) {\n        return; // Not enough landmarks visible\n      }\n\n      // Use the side with better visibility\n      const isLeftSide = leftSideVisible && (!rightSideVisible || leftSideVisible);\n      const supportShoulder = isLeftSide ? leftShoulder : rightShoulder;\n      const supportElbow = isLeftSide ? leftElbow : rightElbow;\n      const supportWrist = isLeftSide ? leftWrist : rightWrist;\n      const supportHip = isLeftSide ? leftHip : rightHip;\n      const supportKnee = isLeftSide ? leftKnee : rightKnee;\n      const supportAnkle = isLeftSide ? leftAnkle : rightAnkle;\n      const supportEar = isLeftSide ? leftEar : rightEar;\n\n      // Calculate key angles for side plank validation\n      \n      // 1. Shoulder Support Angle (shoulder-elbow-wrist) - should be ~90¬∞\n      const shoulderSupportAngle = this.calculateAngle(supportShoulder, supportElbow, supportWrist);\n      const SHOULDER_ANGLE_MIN = spConfig.SHOULDER_ANGLE_MIN || 80;\n      const SHOULDER_ANGLE_MAX = spConfig.SHOULDER_ANGLE_MAX || 100;\n      const shoulderAngleGood = shoulderSupportAngle >= SHOULDER_ANGLE_MIN && shoulderSupportAngle <= SHOULDER_ANGLE_MAX;\n\n      // 2. Torso-Hip Line (shoulder-hip-ankle) - should be ~180¬∞ (straight line)\n      const torsoHipAngle = this.calculateAngle(supportShoulder, supportHip, supportAnkle);\n      const TORSO_ANGLE_MIN = spConfig.TORSO_ANGLE_MIN || 160;\n      const TORSO_ANGLE_MAX = spConfig.TORSO_ANGLE_MAX || 200;\n      const torsoAngleGood = torsoHipAngle >= TORSO_ANGLE_MIN && torsoHipAngle <= TORSO_ANGLE_MAX;\n\n      // 3. Check for hip sag (hip drops below shoulder-ankle line)\n      const shoulderAnkleMidY = (supportShoulder.y + supportAnkle.y) / 2;\n      const hipSagThreshold = spConfig.HIP_SAG_THRESHOLD || 0.05; // normalized units\n      const hipSag = supportHip.y > (shoulderAnkleMidY + hipSagThreshold);\n      \n      // 4. Check for hip hike (hip rises above shoulder-ankle line)\n      const hipHikeThreshold = spConfig.HIP_HIKE_THRESHOLD || 0.05; // normalized units\n      const hipHike = supportHip.y < (shoulderAnkleMidY - hipHikeThreshold);\n\n      // 5. Check elbow alignment (elbow should be under shoulder)\n      const elbowAlignmentThreshold = spConfig.ELBOW_ALIGNMENT_THRESHOLD || 0.08; // normalized units\n      const elbowAligned = Math.abs(supportElbow.x - supportShoulder.x) < elbowAlignmentThreshold;\n\n      // 6. Check feet stacking (ankles should be close together)\n      const feetStackingThreshold = spConfig.FEET_STACKING_THRESHOLD || 0.1; // normalized units\n      const feetStacked = Math.abs(leftAnkle.x - rightAnkle.x) < feetStackingThreshold;\n\n      // 7. Head-neck alignment (ear-shoulder-hip should be ~180¬∞)\n      let headNeckGood = true;\n      if (supportEar && vis(supportEar)) {\n        const headNeckAngle = this.calculateAngle(supportEar, supportShoulder, supportHip);\n        const HEAD_NECK_ANGLE_MIN = spConfig.HEAD_NECK_ANGLE_MIN || 160;\n        const HEAD_NECK_ANGLE_MAX = spConfig.HEAD_NECK_ANGLE_MAX || 200;\n        headNeckGood = headNeckAngle >= HEAD_NECK_ANGLE_MIN && headNeckAngle <= HEAD_NECK_ANGLE_MAX;\n      }\n\n      // Overall posture assessment\n      const isGoodPosture = shoulderAngleGood && \n                           torsoAngleGood && \n                           !hipSag && \n                           !hipHike && \n                           elbowAligned && \n                           feetStacked && \n                           headNeckGood;\n\n      // Debug logging\n      console.log('üîç Side Plank Debug:', {\n        side: isLeftSide ? 'Left' : 'Right',\n        shoulderAngle: Math.round(shoulderSupportAngle),\n        torsoAngle: Math.round(torsoHipAngle),\n        hipSag,\n        hipHike,\n        elbowAligned,\n        feetStacked,\n        headNeckGood,\n        isGoodPosture,\n        postureStatus: this.postureStatus\n      });\n\n      // Update posture status with smoothing\n      if (isGoodPosture) {\n        this._postureGoodCount = (this._postureGoodCount || 0) + 1;\n        this._postureBadCount = 0;\n      } else {\n        this._postureBadCount = (this._postureBadCount || 0) + 1;\n        this._postureGoodCount = 0;\n      }\n\n      const POSTURE_GOOD_FRAMES = spConfig.POSTURE_GOOD_FRAMES || 3;\n      const POSTURE_BAD_FRAMES = spConfig.POSTURE_BAD_FRAMES || 4;\n\n      let smoothedStatus = this.postureStatus;\n      if (this._postureGoodCount >= POSTURE_GOOD_FRAMES) {\n        smoothedStatus = 'correct';\n      } else if (this._postureBadCount >= POSTURE_BAD_FRAMES) {\n        smoothedStatus = 'incorrect';\n      }\n\n      if (smoothedStatus !== this.postureStatus) {\n        this.postureStatus = smoothedStatus;\n        if (this.onPostureChange) this.onPostureChange(this.postureStatus, landmarks);\n      }\n\n      // Handle timing for side plank (similar to regular plank)\n      if (this.postureStatus === 'correct') {\n        const now = Date.now();\n        if (!this.timerRunning) {\n          this.startCorrectTimestampMs = now;\n          this.timerRunning = true;\n        }\n        const totalMs = this.accumulatedCorrectMs + (now - (this.startCorrectTimestampMs || now));\n        const seconds = Math.floor(totalMs / 1000);\n        if (this.onTimeUpdate) this.onTimeUpdate(seconds);\n      } else {\n        // Stop timer when posture is incorrect\n        if (this.timerRunning) {\n          this.accumulatedCorrectMs += Date.now() - this.startCorrectTimestampMs;\n          this.timerRunning = false;\n          this.startCorrectTimestampMs = 0;\n          if (this.onTimeUpdate) {\n            this.onTimeUpdate(Math.floor(this.accumulatedCorrectMs / 1000));\n          }\n        }\n      }\n\n      // Provide form feedback for common mistakes\n      if (!isGoodPosture && this.onFormFeedback) {\n        const currentTime = Date.now();\n        const cooldown = spConfig.WARNING_COOLDOWN || 2000;\n        \n        if (currentTime - this.lastWarningTime > cooldown) {\n          let feedbackMessage = '';\n          if (hipSag) {\n            feedbackMessage = 'Hip sagging - lift your hips up!';\n          } else if (hipHike) {\n            feedbackMessage = 'Hip too high - lower your hips!';\n          } else if (!elbowAligned) {\n            feedbackMessage = 'Keep elbow under shoulder!';\n          } else if (!feetStacked) {\n            feedbackMessage = 'Stack your feet together!';\n          } else if (!shoulderAngleGood) {\n            feedbackMessage = 'Adjust your arm position!';\n          } else if (!torsoAngleGood) {\n            feedbackMessage = 'Keep your body straight!';\n          }\n\n          if (feedbackMessage) {\n            this.onFormFeedback({\n              message: feedbackMessage,\n              type: 'warning',\n              timestamp: currentTime\n            });\n            this.lastWarningTime = currentTime;\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Error updating side plank counter:', error);\n    }\n  }\n\n  // Play warning sound\n  playWarningSound() {\n    try {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      \n      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\n      oscillator.type = 'sine';\n      \n      gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n      gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n      \n      oscillator.start(audioContext.currentTime);\n      oscillator.stop(audioContext.currentTime + 0.5);\n    } catch (error) {\n      console.error('Error playing warning sound:', error);\n    }\n  }\n\n  // Play success sound (pop.wav)\n  playSuccessSound() {\n    try {\n      const audio = new Audio('/assets/sounds/pop.wav');\n      audio.volume = 0.5; // Set volume to 50%\n      audio.play().catch(error => {\n        console.error('Error playing success sound:', error);\n      });\n    } catch (error) {\n      console.error('Error creating success sound:', error);\n    }\n  }\n\n  // Draw pose landmarks on canvas\n  drawPoseOverlay(canvasCtx, results, canvasWidth, canvasHeight) {\n    // Only log occasionally to avoid spam\n    if (Math.random() < 0.05) {\n      console.log('üé® Drawing pose overlay with', results.poseLandmarks?.length || 0, 'landmarks');\n    }\n\n    if (!results.poseLandmarks || !canvasCtx) {\n      return;\n    }\n\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    // Draw landmarks\n    const landmarks = results.poseLandmarks;\n    let drawnLandmarks = 0;\n    \n    landmarks.forEach((landmark, index) => {\n      if (landmark.visibility && landmark.visibility > 0.5) {\n        const x = landmark.x * canvasWidth;\n        const y = landmark.y * canvasHeight;\n        \n        canvasCtx.beginPath();\n        canvasCtx.arc(x, y, 6, 0, 2 * Math.PI); // Bigger circles\n        canvasCtx.fillStyle = landmark.visibility > 0.7 ? '#10B981' : '#F59E0B';\n        canvasCtx.fill();\n        canvasCtx.strokeStyle = '#FFFFFF';\n        canvasCtx.lineWidth = 2;\n        canvasCtx.stroke();\n        drawnLandmarks++;\n      }\n    });\n\n    // Only log occasionally\n    if (Math.random() < 0.1) {\n      console.log('‚ú® Drew', drawnLandmarks, 'landmarks');\n    }\n\n    // Always use basic connections (more reliable)\n    this.drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight);\n\n    canvasCtx.restore();\n  }\n\n  // Draw basic pose connections\n  drawBasicConnections(canvasCtx, landmarks, canvasWidth, canvasHeight) {\n    const connections = [\n      [11, 12], // shoulders\n      [11, 13], // left shoulder to elbow\n      [13, 15], // left elbow to wrist\n      [12, 14], // right shoulder to elbow\n      [14, 16], // right elbow to wrist\n      [11, 23], // left shoulder to hip\n      [12, 24], // right shoulder to hip\n      [23, 24], // hips\n      [23, 25], // left hip to knee\n      [25, 27], // left knee to ankle\n      [24, 26], // right hip to knee\n      [26, 28]  // right knee to ankle\n    ];\n\n    let drawnConnections = 0;\n    connections.forEach(([startIdx, endIdx]) => {\n      const startPoint = landmarks[startIdx];\n      const endPoint = landmarks[endIdx];\n\n      if (startPoint && endPoint && \n          startPoint.visibility > 0.5 && endPoint.visibility > 0.5) {\n        canvasCtx.beginPath();\n        canvasCtx.moveTo(startPoint.x * canvasWidth, startPoint.y * canvasHeight);\n        canvasCtx.lineTo(endPoint.x * canvasWidth, endPoint.y * canvasHeight);\n        canvasCtx.strokeStyle = '#3B82F6';\n        canvasCtx.lineWidth = 3; // Thicker lines\n        canvasCtx.stroke();\n        drawnConnections++;\n      }\n    });\n    \n    // Only log occasionally\n    if (Math.random() < 0.02) {\n      console.log('‚úÖ Drawing completed!', drawnConnections, 'connections');\n    }\n  }\n\n  // Reset counter\n  resetCounter() {\n    // Reset only the counters/state for the currently selected exercise\n    const mode = this.exerciseMode;\n    if (this.perModeState && this.perModeState[mode]) {\n      this.perModeState[mode].count = 0;\n      this.perModeState[mode].state = 'up';\n      // reset mode-specific extras\n      if (mode === 'mountainclimbers') {\n        this.perModeState[mode]._lastLeftKneeY = null;\n        this.perModeState[mode]._lastRightKneeY = null;\n        this.perModeState[mode]._climberState = 'neutral';\n        this.perModeState[mode]._lastClimberTime = 0;\n      }\n      if (mode === 'burpees') {\n        this.perModeState[mode]._burpeeState = 'ready';\n      }\n      if (mode === 'jumpingjacks') {\n        this.perModeState[mode]._lastRepAt = 0;\n      }\n      if (mode === 'sideplank') {\n        // Reset side plank state\n        this.perModeState[mode].state = 'neutral';\n        this.perModeState[mode].count = 0;\n      }\n      if (mode === 'plank') {\n        // Reset plank stability/timing helpers\n        this.perModeState[mode]._stableCount = 0;\n        this.perModeState[mode]._lastHipY = null;\n        this.perModeState[mode]._lastShoulderY = null;\n        this.perModeState[mode]._lastAnkleY = null;\n        this.perModeState[mode]._lastTimestamp = 0;\n      }\n    }\n    this.postureStatus = 'unknown';\n    // Reset plank timing\n    this.accumulatedCorrectMs = 0;\n    this.timerRunning = false;\n    this.startCorrectTimestampMs = 0;\n  }\n\n  // Get current stats\n  getStats() {\n    const mode = this.exerciseMode;\n    const stateObj = this.perModeState && this.perModeState[mode] ? this.perModeState[mode] : { count: 0, state: 'up' };\n    return {\n      count: stateObj.count || 0,\n      state: stateObj.state || 'up',\n      posture: this.postureStatus,\n      timeSec: Math.floor((this.accumulatedCorrectMs + (this.timerRunning ? (Date.now() - this.startCorrectTimestampMs) : 0)) / 1000)\n    };\n  }\n\n  // Get latest pose results for drawing\n  getLastResults() {\n    return this.lastResults;\n  }\n\n  // Set callback functions\n  setCallbacks({ onPushupCount, onPostureChange, onFormFeedback, onTimeUpdate }) {\n    this.onPushupCount = onPushupCount;\n    this.onPostureChange = onPostureChange;\n    this.onFormFeedback = onFormFeedback;\n    this.onTimeUpdate = onTimeUpdate;\n  }\n\n  // Cleanup\n  cleanup() {\n    if (this.pose) {\n      this.pose.close();\n      this.pose = null;\n    }\n    this.isInitialized = false;\n  }\n}\n\nexport default PoseDetectionUtils;\n"],"names":["PoseDetectionUtils","constructor","this","pose","isInitialized","perModeState","state","count","_lastLeftKneeY","_lastRightKneeY","_climberState","_lastClimberTime","_stableCount","_lastHipY","_lastShoulderY","_lastAnkleY","_lastTimestamp","postureStatus","lastWarningTime","videoDimensionsLogged","exerciseMode","accumulatedCorrectMs","timerRunning","startCorrectTimestampMs","onPushupCount","onPostureChange","onFormFeedback","onTimeUpdate","setExerciseMode","mode","normalized","String","toLowerCase","includes","initialize","_a","window","Pose","attempts","Promise","resolve","setTimeout","locateFile","file","config","MediaPipeConfig","POSE_CONFIG","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","setOptions","onResults","bind","error","processFrame","videoElement","Math","random","videoWidth","videoHeight","maxWidth","maxHeight","send","image","message","results","_b","_c","_d","_e","_f","_g","_h","_i","lastResults","poseLandmarks","Date","now","floor","landmarks","isPostureCorrectInstant","checkBackAlignment","_postureGoodCount","_postureBadCount","POSTURE_GOOD_FRAMES","SQUAT_CONFIG","POSTURE_BAD_FRAMES","smoothedStatus","cfg","POSE_LANDMARKS","leftHip","LEFT_HIP","rightHip","RIGHT_HIP","leftKnee","LEFT_KNEE","rightKnee","RIGHT_KNEE","hipCenter","x","y","kneeCenter","currentTime","cooldown","PLANK_CONFIG","WARNING_COOLDOWN","playWarningSound","type","timestamp","isPlankStrictAndStable","totalMs","seconds","updateSquatCounter","updateLungesCounter","updateBurpeesCounter","updateMountainClimbersCounter","updateHighKneesCounter","updateJumpingJacksCounter","updateSidePlankCounter","updatePushupCounter","calculateAngle","point1","point2","point3","radians","atan2","angle","abs","PI","nowMs","LEFT_SHOULDER","RIGHT_SHOULDER","LEFT_ANKLE","RIGHT_ANKLE","leftShoulder","rightShoulder","leftAnkle","rightAnkle","vis","p","visibility","leftSideOk","rightSideOk","horizontalOk","MIN_SIDE_ANGLE","shoulderCenter","dx","dy","orientDeg","HORIZ_MAX","HORIZ_MAX_DEG","hipY","shoulderY","ankleY","maxDeltaPerSec","MAX_DELTA_PER_SEC","dt","max","hipDelta","shoulderDelta","ankleDelta","motionTooHigh","REQUIRED_STABLE_FRAMES","stableEnough","hipAnkleDy","MIN_HIP_ANKLE_DY","e","isPushupStartPose","shoulderCenterY","hipCenterY","torsoDy","PUSHUP_CONFIG","START_TORSO_DY","isSquatStartPose","kneeY","START_HIP_KNEE_GAP","angDeg","MIN_VERT","STANDING_TORSO_MIN_DEG","MAX_VERT","STANDING_TORSO_MAX_DEG","ankleCenter","targetPoint","v1","v2","isGoodPosture","leftSideVisible","rightSideVisible","shoulder","hip","ankle","sideAngle","leftKneeAngle","rightKneeAngle","kneeMin","KNEE_MIN_DEG","cosSim","mag1","hypot","mag2","absCos","min","straightEnough","STRAIGHT_ABS_COS_MIN","horizMax","nearHorizontal","kneeOk","scfg","hipAngleLeft","hipAngle","hipAngleMin","HIP_ANGLE_MIN","collapseThreshold","HIP_ANGLE_COLLAPSE","torsoTiltDeg","tiltMax","TORSO_TILT_MAX","hipBelowKnee","collapseTiltMin","COLLAPSE_TILT_MIN","SIDE_ABS_COS_MIN","HORIZ_TORSO_MAX_DEG","pushupConfig","leftElbow","LEFT_ELBOW","leftWrist","LEFT_WRIST","rightElbow","RIGHT_ELBOW","rightWrist","RIGHT_WRIST","leftElbowAngle","avgElbowAngle","avgShoulderY","downThreshold","ELBOW_ANGLE_DOWN","upThreshold","ELBOW_ANGLE_UP","shoulderHeightThreshold","SHOULDER_HEIGHT_DOWN","shoulderHipDy","isLikelyStanding","TORSO_VERTICAL_DY","STANDING_DY_MIN","pstate","_baselineShoulderY","shoulderDrop","shoulderDropThreshold","SHOULDER_DROP_THRESHOLD","pushupPosition","standingPosition","_inPositionCount","START_STABLE_FRAMES","_isInStartPose","MIN_REP_MS","_lastRepAt","playSuccessSound","head","NOSE","HORIZONTAL_THRESHOLD","headHipDy","isHorizontalLikePushup","leftFoot","rightFoot","HANDS_ON_GROUND_THRESHOLD","handsOnGround","avgWristY","knee","kneeAngleLeft","leftKneeY","rightKneeY","kneeHeightDiff","legsStable","hipAboveKnee","stateObj","LUNGES_CONFIG","leftKneeBent","frontKnee","frontKneeAngle","backKneeAngle","rightKneeBent","altFrontKneeAngle","altBackKneeAngle","KNEE_Y_DIFF_THRESHOLD","BACK_KNEE_ANGLE_THRESHOLD","FRONT_KNEE_ANGLE_THRESHOLD","HIP_FORWARD_THRESHOLD","oneLegForward","backKneeBent","frontKneeBent","frontHip","frontAnkle","hipForwardLean","lungePosition1","altBackKneeBent","altFrontKneeBent","altFrontHip","altFrontAnkle","altHipForwardLean","lungePosition","lstate","KNEE_THRESHOLD","MIN_REP_TIME","leftKneeMove","rightKneeMove","isAlternating","cmode","leg","nose","leftIndex","LEFT_INDEX","rightIndex","RIGHT_INDEX","headY","leftHandY","rightHandY","handsAboveHead","_burpeeState","bstate","KNEE_HIP_THRESHOLD","isLeftKneeHigh","isRightKneeHigh","isDoingHighKnees","hk","_highKneesState","_startTime","_lastUpdateTime","elapsedSeconds","jjConfig","JUMPINGJACKS_CONFIG","leftShoulderAbduction","rightShoulderAbduction","leftHipAbduction","rightHipAbduction","SHOULDER_ABDUCTION_DOWN","SHOULDER_ABDUCTION_UP","HIP_ABDUCTION_DOWN","HIP_ABDUCTION_UP","avgShoulderAbduction","avgHipAbduction","armsOverhead","legsApart","isUpState","isDownState","jjState","_lastStateChange","spConfig","SIDEPLANK_CONFIG","leftEar","LEFT_EAR","rightEar","RIGHT_EAR","isLeftSide","supportShoulder","supportElbow","supportWrist","supportHip","supportAnkle","supportEar","shoulderSupportAngle","SHOULDER_ANGLE_MIN","SHOULDER_ANGLE_MAX","shoulderAngleGood","torsoHipAngle","TORSO_ANGLE_MIN","TORSO_ANGLE_MAX","torsoAngleGood","shoulderAnkleMidY","hipSagThreshold","HIP_SAG_THRESHOLD","hipSag","hipHikeThreshold","HIP_HIKE_THRESHOLD","hipHike","elbowAlignmentThreshold","ELBOW_ALIGNMENT_THRESHOLD","elbowAligned","feetStackingThreshold","FEET_STACKING_THRESHOLD","feetStacked","headNeckGood","headNeckAngle","HEAD_NECK_ANGLE_MIN","HEAD_NECK_ANGLE_MAX","feedbackMessage","audioContext","AudioContext","webkitAudioContext","oscillator","createOscillator","gainNode","createGain","connect","destination","frequency","setValueAtTime","gain","linearRampToValueAtTime","exponentialRampToValueAtTime","start","stop","audio","Audio","volume","play","catch","drawPoseOverlay","canvasCtx","canvasWidth","canvasHeight","save","clearRect","forEach","landmark","index","beginPath","arc","fillStyle","fill","strokeStyle","lineWidth","stroke","drawBasicConnections","restore","startIdx","endIdx","startPoint","endPoint","moveTo","lineTo","resetCounter","getStats","posture","timeSec","getLastResults","setCallbacks","cleanup","close"],"mappings":"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"}